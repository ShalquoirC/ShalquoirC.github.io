[{"title":"Unity教程笔记——Ruby‘s Adventure","url":"http://example.com/2021/01/19/Unity教程笔记——Ruby‘s Adventure/","content":"Unity教程笔记——Ruby‘s Adventure有一段时间没有使用unity了之前学习Michael教程的Sunny中的一些技巧差不多忘了，故重头开始学习一个2D项目，并记录笔记加强印象。\n基本操作角色移动首先定义一个公共变量 speed 并对其赋值\n控制角色移动逻辑很简单，围绕 \n1transform.Translate(transform.right * speed * Time.deltaTime);\n最后的实现\n123456float moveX = Input.GetAxisRaw(&quot;Horizontal&quot;);      float moveY = Input.GetAxisRaw(&quot;Vertical&quot;);      Vector2 position = transform.position;      position.x += moveX * speed * Time.deltaTime;      position.y += moveY * speed * Time.deltaTime;      transform.position = position;\n锁定方向在同其他刚体碰撞的时候，精灵图片可能会旋转，在2D游戏中这很不合理。所以需要解决。在运动精灵的Rigidbody2D 的Constraints中锁定Z。\n解决抖动问题获取Rigidbody2D\n12345private Rigidbody2D rbody;void Start()&#123;    rbody = GetComponent&lt;Rigidbody2D&gt;();&#125;\n移动脚本中修改为移动精灵的Rigidbody组件位置\n123456float moveX = Input.GetAxisRaw(&quot;Horizontal&quot;);float moveY = Input.GetAxisRaw(&quot;Vertical&quot;);Vector2 position = rbody.position;position.x += moveX * speed * Time.deltaTime;position.y += moveY * speed * Time.deltaTime;rbody.MovePosition( position);\n瓦片碰撞体给TIlemap 添加tillemap Collider 2D，对应图片素材可进行设置\n\n\n添加Composite Collider2D 并设置Rigidbody为静态。\n2D图片精灵操作​    一般情况下，我们的素材大小并不统一，在将素材图片设置为素材后，根据素材属性（192×192）在Inspector中设置 Pixels Per Unit成适当的大小（64，切成3×3的瓦片），以保证单位方格的正确填充。\n图层排序在添加精灵时，通过设置精灵的Order in Layer可以对精灵的图层顺序进行简单的排序，但在处理一些其他情况的时候就不大合理了，案例中狐狸在树前树后的排序就会出现问题。\n\n为了保证角色同其他物件的正确排序，需要在项目设置中(Edit-Project Setting-Graphics)中设置 透明度分类设置(Transparency Sort mode) 为自定义(Custom Axis) ，并设置Transparency Sort Axis为如下\n\nTransparency Sort Axis控制同一层级的显示顺序，默认 XY0，Z1，改为Y1Z0，用来符合2D规则。\n(一半一半规律，a精灵在b精灵之下50%，则a覆盖b，反之b覆盖a)\n摄像机安装unity自带的包Cinema Machine，安装完成后上方栏位多出Cinemachine，其中可添加2d camera。\n","categories":[],"tags":[]},{"title":"Coroutine","url":"http://example.com/2021/01/17/Coroutine协同程序/","content":"Coroutine协同程序(较难)MonoBehaviour.StartCoroutine(string methodName)方法打开另一个协同程序（线程）\nIEnumerator \nyield: 声明序列中的下一个值或者是一个无意义的值。 \n\n如果使用yield x（x是指一个具体的对象或数值）的话，那么movenext返回为true并且current被赋值为x\n如果使用yield break使得movenext()返回false。 \n\n12345678910IEnumerator LongComputation()&#123;    while(someCondition)    &#123;        /* 做一系列的工作 */         // 在这里暂停然后在下一帧继续执行        yield return null;    &#125;&#125;\n\n\nStopCoroutine(string methodName)\nStopAllCoroutines()\n","categories":[],"tags":[]},{"title":"Naninovel开坑笔记","url":"http://example.com/2021/01/17/Naninovel开坑笔记/","content":"​        近期需要开发一个视觉小说游戏，经过一番了解，最终选择Naninovel这个unity插件进行开发。\n目前美术团队的能力可能不够，先列出自己目标的学习路径以加快开发。\n\n背景图片的使用(大小、比例、切换)\n\n背景音乐的使用(响应的时机、循环、音量）\n\n相机的使用\n\n人物\n\n选择处理器\n\n存档管理\n\n安置其他游戏\n\n\n一、Naninovel脚本Naninovel脚本文件(.nani) 作为视觉小说的\n\n\n\n前缀符号\n表达类型\n\n\n\n@\n命名行\n\n\n#\n标签行\n\n\n；\n注释行\n\n\n无前缀时，就被视为普通内容文本行。\n 编写naninovel脚本时，可以使用花括号将表达式构造注入命令参数值和通用文本行{}： \n1234@input color summary:&quot;你最喜欢什么颜色?&quot;@save@stop&#123;color&#125;,嗯，嗯?&#123;color &#x3D;&#x3D;&quot;蓝色&quot;? &quot;我也是!&quot;:&quot;哦。。。&quot;&#125;\n在{}中可使用数学运算，自定义变量（如上）\n变量：\n\n一般情况作用于局部范围，这样的化玩家重新开始新游戏或加载了其他烂尾的游戏后，该值会丢失。大部分变量适用于这种情况。\n\n如果想要将变量存储于全局范围，在其变量名前加上G_或g_\n\n\n","categories":[],"tags":[]},{"title":"Unity3D光照","url":"http://example.com/2021/01/17/Unity3D 光照/","content":"Unity3D 光照Directlight\ntransform\nlightbaking(烘培)\ncolor（颜色）\nIntensity(强度)\nBounce Intensity(反射强度)\nShadows（阴影)\nCookies(遮挡)\nRender Mode(渲染模式)\nCilling Mask（剔除遮挡)\n\n可以选择性（层）照亮\n可以用于照亮角色（显示轮廓）\n天花板、墙面均匀光照\n\nArea Light仅作用于baking\nMesh Renderer属性\n\n\n属性：\n功能：\n\n\n\nLight Probes\n基于探针的光照插值模式。\n\n\nOff\n渲染器不使用任何插值光照探针。\n\n\nBlend Probes\n渲染器使用一个插值光照探针。这是默认选项。\n\n\nUse Proxy Volume\n渲染器使用插值光照探针的 3D 网格。\n\n\nReflection Probes\n指定游戏对象如何受场景中的反射影响。不能在延迟渲染模式下禁用此属性。\n\n\nOff\n禁用反射探针，将天空盒用于反射。\n\n\nBlend Probes\n启用反射探针。混合仅发生在探针之间，在室内环境中非常有用。如果附近没有反射探针，则渲染器将使用默认反射，但默认反射和探针之间不会发生混合。\n\n\nBlend Probes and Skybox\n启用反射探针。混合发生在探针之间或探针与默认反射之间，对于室外环境非常有用。\n\n\nSimple\n启用反射探针，但当存在两个重叠的探针体积时，探针之间不会发生混合。\n\n\nAnchor Override\n使用光照探针或反射探针系统时用变换来确定插值位置。\n\n\nCast Shadows\n\n\n\nOn\n阴影投射光源照在网格上时将投射阴影\n\n\nOff\n网格不会投射阴影\n\n\nTwo Sided\n从网格的任一侧投射双面阴影。Enlighten 和渐进光照贴图 (Progressive Lightmapper) 不支持双面阴影。\n\n\nShadows Only\n网格的阴影将可见，但网格本身不可见\n\n\nReceive Shadows\n启用此复选框可使网格显示任何投射在网格上的阴影。仅当使用渐进光照贴图时才支持 Review Shadows 选项\n\n\nMotion Vectors\n如果启用此属性，则线会将运动矢量渲染到摄像机运动矢量纹理中。\n\n\nLightmap Static\n启用此复选框可向 Unity 指示该游戏对象的位置是固定的并将参与全局光照计算。如果某个游戏对象未标记为 Lightmap Static，则仍可使用光照探针为该对象提供光照。\n\n\nMaterials\n用于渲染模型的材质列表。\n\n\nDynamic Occluded\n启用此复选框可向 Unity 指示即使该对象未标记为静态，仍应该对该游戏对象执行遮挡剔除。\n\n\n小物品可以关闭阴影，减少计算量\n伪造阴影（绘制贴图（ps绘制阴影）\n选择目标位置 羽化 填充 正片叠底不透明度\n投影器effect  projector\n绘制阴影 \nps  \n不均匀的阴影\n\nColor Dynamics（动态颜色）\nScattering（散布）\n\n导出png后\n1.导入unity 将Texture Type 改为Advanced（高级）\n2.Wrap Mode（循环模式）改为Clamp（强制拉伸）\n3.勾选Border Mip Maps（边界多级渐进纹理）消除奇怪的边界线\n4.在光照纹理中 点击select 找到对应的伪阴影。\n5.应用，将点投影器移动到目标的位置 \n6.将物体和投影器绑定\n","categories":[],"tags":[]},{"title":"Unity3d光照渲染","url":"http://example.com/2021/01/17/untiy 3D 光照渲染/","content":"untiy 3D 光照渲染1.HDR文件给skybox替换天空\n\nTextture Type：cubemap\n\n2.Lighting 界面\n\nScene 属性skybox 进行修改\n\n3D 产品展示\n3D environment插件（做一些简单\n静态光照执行照明计算非常昂贵。延迟渲染使我们可以使用很多灯光，但是阴影仍然是一个限制因素。如果场景是动态的，那么我们将不可避免地执行这些计算。但是，如果光源和几何物体都不变，那么我们可以只计算一次光源并重复使用它。这样的话就可以在我们的场景中放置许多灯光，而又不必在运行时渲染它们。也可以使用区域光，但这些区域光同样不能用作实时照明。\n1.1烘培光\n主定向光转换为烘培光之后，它不再包含在动态光照中。 对于动态对象，就不存在光，只剩下环境照明。\nLighting窗口中（window-rendering-lighting settig)\n实际启用灯光映射，在Mixed LIghting 中\n\nLighting Mode设置为 Baked Indirect   ——向场景添加间接光\n启用 Baked Global Illumination\n\nAmbient Occlusion","categories":[],"tags":[]},{"title":"脚本调试优化&内存管理","url":"http://example.com/2021/01/17/脚本调试优化&内存管理/","content":"脚本调试优化&amp;内存管理Fixedupdate()&amp;Update()主要区别\nUpdate()在每次渲染新的一帧时执行，受到当前渲染物体的影响。渲染的帧率会变化，渲染的时间间隔也会变化，也就是说Update()更新频率和设备的性能有关。\n\nFixedupdate()不受帧率的影响，以固定的时间间隔被调用\nFixedupdate()运用于物理引擎；Update因为受渲染物体的影响，所以更多的把Update运用于脚本的逻辑控制。\n注意点\n尽量不要在Update()中执行Find、FindObjectOfType、FindGameobjectswithtag这些寻找物体的函数；尽量在awake start中调用\n引用一个游戏对象的逻辑可以在最开始的时候定义它\n当程序不必每帧都执行的时候，可以使用Coroutines函数，定时重复调用可以使用Invokerepeating函数实现。\n尽量减少使用临时变量，（尤其在Update实时调用的函数中）\n在游戏暂停、场景切换时，可以主动进行垃圾回收。\n\n\n\n","categories":[],"tags":[]}]